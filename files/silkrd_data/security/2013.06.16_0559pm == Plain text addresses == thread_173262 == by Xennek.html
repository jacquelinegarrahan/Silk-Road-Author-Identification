<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
		<meta name="robots" content="noindex" />
		<link rel="canonical" href="http://dkn255hz262ypmii.onion/index.php?topic=173262.0" />
		<title>Print Page - Plain text addresses </title>
		<style type="text/css">
			body, a
			{
				color: #000;
				background: #fff;
			}
			body, td, .normaltext
			{
				font-family: Verdana, arial, helvetica, serif;
				font-size: small;
			}
			h1#title
			{
				font-size: large;
				font-weight: bold;
			}
			h2#linktree
			{
				margin: 1em 0 2.5em 0;
				font-size: small;
				font-weight: bold;
			}
			dl#posts
			{
				width: 90%;
				margin: 0;
				padding: 0;
				list-style: none;
			}
			dt.postheader
			{
				border: solid #000;
				border-width: 1px 0;
				padding: 4px 0;
			}
			dd.postbody
			{
				margin: 1em 0 2em 2em;
			}
			table
			{
				empty-cells: show;
			}
			blockquote, code
			{
				border: 1px solid #000;
				margin: 3px;
				padding: 1px;
				display: block;
			}
			code
			{
				font: x-small monospace;
			}
			blockquote
			{
				font-size: x-small;
			}
			.smalltext, .quoteheader, .codeheader
			{
				font-size: x-small;
			}
			.largetext
			{
				font-size: large;
			}
			.centertext
			{
				text-align: center;
			}
			hr
			{
				height: 1px;
				border: 0;
				color: black;
				background-color: black;
			}
		</style>
	</head>
	<body>
		<h1 id="title">Silk Road forums</h1>
		<h2 id="linktree">Discussion => Security => Topic started by: Xennek on June 16, 2013, 05:59 pm</h2>
		<dl id="posts">
			<dt class="postheader">
				Title: <strong>Plain text addresses </strong><br />
				Post by: <strong>Xennek</strong> on <strong>June 16, 2013, 05:59 pm</strong>
			</dt>
			<dd class="postbody">
				Why don&#039;t more people encrypt or at least privnote their addresses? Is there absolutely anything stopping LEAs/ &quot;good&quot; guys running a compromised exit node from reading your order list and adding all of the addresses to a watch list? Seems like an easy way to get nabbed to me.
			</dd>
			<dt class="postheader">
				Title: <strong>Re: Plain text addresses </strong><br />
				Post by: <strong>SelfSovereignty</strong> on <strong>June 16, 2013, 06:02 pm</strong>
			</dt>
			<dd class="postbody">
				Yes, there&#039;s a perfectly good reason they can&#039;t do that: traffic to and from Silk Road never goes through an exit node.&nbsp; It&#039;s all encrypted end-to-end in the Tor network and never leaves, thus is never sent unencrypted.<br /><br />It&#039;s only stored unencrypted on the server and displayed unencrypted on the vendor&#039;s (and the buyer&#039;s) computers.
			</dd>
			<dt class="postheader">
				Title: <strong>Re: Plain text addresses </strong><br />
				Post by: <strong>tree</strong> on <strong>June 16, 2013, 06:22 pm</strong>
			</dt>
			<dd class="postbody">
				<div class="quoteheader"><div class="topslice_quote"><a href="http://dkn255hz262ypmii.onion/index.php?topic=173262.msg1244149#msg1244149">Quote from: Xennek on June 16, 2013, 05:59 pm</a></div></div><blockquote class="bbc_standard_quote">Why don&#039;t more people encrypt or at least privnote their addresses? Is there absolutely anything stopping LEAs/ &quot;good&quot; guys running a compromised exit node from reading your order list and adding all of the addresses to a watch list? Seems like an easy way to get nabbed to me.<br /></blockquote><div class="quotefooter"><div class="botslice_quote"></div></div>Why would you think that privnote is safer than using the address field? Your address is automatically deleted from SR&#039;s servers too so why use a third party to do that for you? Privnote could keep a copy of all its messages for all we know.
			</dd>
			<dt class="postheader">
				Title: <strong>Re: Plain text addresses </strong><br />
				Post by: <strong>SelfSovereignty</strong> on <strong>June 16, 2013, 06:41 pm</strong>
			</dt>
			<dd class="postbody">
				<div class="quoteheader"><div class="topslice_quote"><a href="http://dkn255hz262ypmii.onion/index.php?topic=173262.msg1244190#msg1244190">Quote from: tree on June 16, 2013, 06:22 pm</a></div></div><blockquote class="bbc_standard_quote"><div class="quoteheader"><div class="topslice_quote"><a href="http://dkn255hz262ypmii.onion/index.php?topic=173262.msg1244149#msg1244149">Quote from: Xennek on June 16, 2013, 05:59 pm</a></div></div><blockquote class="bbc_alternate_quote">Why don&#039;t more people encrypt or at least privnote their addresses? Is there absolutely anything stopping LEAs/ &quot;good&quot; guys running a compromised exit node from reading your order list and adding all of the addresses to a watch list? Seems like an easy way to get nabbed to me.<br /></blockquote><div class="quotefooter"><div class="botslice_quote"></div></div>Why would you think that privnote is safer than using the address field? Your address is automatically deleted from SR&#039;s servers too so why use a third party to do that for you? Privnote could keep a copy of all its messages for all we know.<br /></blockquote><div class="quotefooter"><div class="botslice_quote"></div></div><br />Privnote actually was -- at least at the time that I looked at it -- just as safe as PGP.&nbsp; Though I didn&#039;t go over it line by line or anything; still, the only real problem with it is that the code to encrypt stuff is downloaded on-the-fly from the server, and there&#039;s no guarantee that it hasn&#039;t changed since someone last looked at it.<br /><br />By design, there will never be a guarantee that the code you download to encrypt the message wasn&#039;t changed the moment prior to you downloading it.&nbsp; That&#039;s why it isn&#039;t secure, but to my knowledge it&#039;s the only reason.
			</dd>
			<dt class="postheader">
				Title: <strong>Re: Plain text addresses </strong><br />
				Post by: <strong>tree</strong> on <strong>June 16, 2013, 06:50 pm</strong>
			</dt>
			<dd class="postbody">
				Oh I see, thanks for clarifying that. I would&#039;ve thought privnote could somehow keep a copy of your message or not delete them. Does the source code of their site reveal that they can&#039;t?<br /><br />I remember Pine was pretty opposed to using privnote though.
			</dd>
			<dt class="postheader">
				Title: <strong>Re: Plain text addresses </strong><br />
				Post by: <strong>SelfSovereignty</strong> on <strong>June 16, 2013, 07:16 pm</strong>
			</dt>
			<dd class="postbody">
				Um... Yeah, uh... I&#039;m taking another look at this, and I&#039;m going to retract my statement.&nbsp; I&#039;m not so sure anymore, frankly: I&#039;m quite positive that nothing is transmitted to the servers unencrypted.&nbsp; I am 100% _not_ positive however that the key to decrypt this shit is not in their possession.
			</dd>
			<dt class="postheader">
				Title: <strong>Re: Plain text addresses </strong><br />
				Post by: <strong>tree</strong> on <strong>June 16, 2013, 09:31 pm</strong>
			</dt>
			<dd class="postbody">
				Well I wasn&#039;t gonna start using privnote because of what you said anyways, I just found it interesting that it was pretty secure according to you. I prefer using PGP so I don&#039;t really care that much but for those that can&#039;t handle PGP it may be good to know how secure it really is.
			</dd>
			<dt class="postheader">
				Title: <strong>Re: Plain text addresses </strong><br />
				Post by: <strong>pakchoi23</strong> on <strong>June 16, 2013, 10:17 pm</strong>
			</dt>
			<dd class="postbody">
				<div class="quoteheader"><div class="topslice_quote"><a href="http://dkn255hz262ypmii.onion/index.php?topic=173262.msg1244149#msg1244149">Quote from: Xennek on June 16, 2013, 05:59 pm</a></div></div><blockquote class="bbc_standard_quote">Why don&#039;t more people encrypt or at least privnote their addresses? <br /></blockquote><div class="quotefooter"><div class="botslice_quote"></div></div><br />Laziness and stupidity.<br /><br />And yes, privnote is bad. Insecure. Not trust worthy.<br /><br />
			</dd>
			<dt class="postheader">
				Title: <strong>Re: Plain text addresses </strong><br />
				Post by: <strong>kmfkewm</strong> on <strong>June 17, 2013, 10:03 am</strong>
			</dt>
			<dd class="postbody">
				<div class="quoteheader"><div class="topslice_quote"><a href="http://dkn255hz262ypmii.onion/index.php?topic=173262.msg1244234#msg1244234">Quote from: SelfSovereignty on June 16, 2013, 06:41 pm</a></div></div><blockquote class="bbc_standard_quote"><div class="quoteheader"><div class="topslice_quote"><a href="http://dkn255hz262ypmii.onion/index.php?topic=173262.msg1244190#msg1244190">Quote from: tree on June 16, 2013, 06:22 pm</a></div></div><blockquote class="bbc_alternate_quote"><div class="quoteheader"><div class="topslice_quote"><a href="http://dkn255hz262ypmii.onion/index.php?topic=173262.msg1244149#msg1244149">Quote from: Xennek on June 16, 2013, 05:59 pm</a></div></div><blockquote class="bbc_standard_quote">Why don&#039;t more people encrypt or at least privnote their addresses? Is there absolutely anything stopping LEAs/ &quot;good&quot; guys running a compromised exit node from reading your order list and adding all of the addresses to a watch list? Seems like an easy way to get nabbed to me.<br /></blockquote><div class="quotefooter"><div class="botslice_quote"></div></div>Why would you think that privnote is safer than using the address field? Your address is automatically deleted from SR&#039;s servers too so why use a third party to do that for you? Privnote could keep a copy of all its messages for all we know.<br /></blockquote><div class="quotefooter"><div class="botslice_quote"></div></div><br />Privnote actually was -- at least at the time that I looked at it -- just as safe as PGP.&nbsp; Though I didn&#039;t go over it line by line or anything; still, the only real problem with it is that the code to encrypt stuff is downloaded on-the-fly from the server, and there&#039;s no guarantee that it hasn&#039;t changed since someone last looked at it.<br /><br />By design, there will never be a guarantee that the code you download to encrypt the message wasn&#039;t changed the moment prior to you downloading it.&nbsp; That&#039;s why it isn&#039;t secure, but to my knowledge it&#039;s the only reason.<br /></blockquote><div class="quotefooter"><div class="botslice_quote"></div></div><br />SelfSovereignty please stop making claims about technical things that you very clearly don&#039;t have a clue about, it is getting extremely annoying. Privnote is not anywhere near as secure as GPG. For one they could backdoor the code just like you said. For two you need to transfer the URL in plaintext or encrypt it with GPG, opening it up to massive MITM potential. The fact that a message is deleted automatically doesn&#039;t mean jack shit since somebody who does MITM will just intercept , read, make a new message. GPG is for getting around issues like that, privnote doesn&#039;t do jack shit to solve the underlying issues. Not to mention it is written in javascript, which is hardly the ideal language for doing crypto shit in. Not to mention you have not even looked at the code so how the hell are you to know if it is secure or not? Oh not to mention when you use privnote you are weak to your Tor exit node sending you a bugged version of the javascript client. 
			</dd>
			<dt class="postheader">
				Title: <strong>Re: Plain text addresses </strong><br />
				Post by: <strong>SelfSovereignty</strong> on <strong>June 17, 2013, 10:23 pm</strong>
			</dt>
			<dd class="postbody">
				<div class="quoteheader"><div class="topslice_quote"><a href="http://dkn255hz262ypmii.onion/index.php?topic=173262.msg1246178#msg1246178">Quote from: kmfkewm on June 17, 2013, 10:03 am</a></div></div><blockquote class="bbc_standard_quote"><div class="quoteheader"><div class="topslice_quote"><a href="http://dkn255hz262ypmii.onion/index.php?topic=173262.msg1244234#msg1244234">Quote from: SelfSovereignty on June 16, 2013, 06:41 pm</a></div></div><blockquote class="bbc_alternate_quote"><div class="quoteheader"><div class="topslice_quote"><a href="http://dkn255hz262ypmii.onion/index.php?topic=173262.msg1244190#msg1244190">Quote from: tree on June 16, 2013, 06:22 pm</a></div></div><blockquote class="bbc_standard_quote"><div class="quoteheader"><div class="topslice_quote"><a href="http://dkn255hz262ypmii.onion/index.php?topic=173262.msg1244149#msg1244149">Quote from: Xennek on June 16, 2013, 05:59 pm</a></div></div><blockquote class="bbc_alternate_quote">Why don&#039;t more people encrypt or at least privnote their addresses? Is there absolutely anything stopping LEAs/ &quot;good&quot; guys running a compromised exit node from reading your order list and adding all of the addresses to a watch list? Seems like an easy way to get nabbed to me.<br /></blockquote><div class="quotefooter"><div class="botslice_quote"></div></div>Why would you think that privnote is safer than using the address field? Your address is automatically deleted from SR&#039;s servers too so why use a third party to do that for you? Privnote could keep a copy of all its messages for all we know.<br /></blockquote><div class="quotefooter"><div class="botslice_quote"></div></div><br />Privnote actually was -- at least at the time that I looked at it -- just as safe as PGP.&nbsp; Though I didn&#039;t go over it line by line or anything; still, the only real problem with it is that the code to encrypt stuff is downloaded on-the-fly from the server, and there&#039;s no guarantee that it hasn&#039;t changed since someone last looked at it.<br /><br />By design, there will never be a guarantee that the code you download to encrypt the message wasn&#039;t changed the moment prior to you downloading it.&nbsp; That&#039;s why it isn&#039;t secure, but to my knowledge it&#039;s the only reason.<br /></blockquote><div class="quotefooter"><div class="botslice_quote"></div></div><br />SelfSovereignty please stop making claims about technical things that you very clearly don&#039;t have a clue about, it is getting extremely annoying. Privnote is not anywhere near as secure as GPG. For one they could backdoor the code just like you said. For two you need to transfer the URL in plaintext or encrypt it with GPG, opening it up to massive MITM potential. The fact that a message is deleted automatically doesn&#039;t mean jack shit since somebody who does MITM will just intercept , read, make a new message. GPG is for getting around issues like that, privnote doesn&#039;t do jack shit to solve the underlying issues. Not to mention it is written in javascript, which is hardly the ideal language for doing crypto shit in. Not to mention you have not even looked at the code so how the hell are you to know if it is secure or not? Oh not to mention when you use privnote you are weak to your Tor exit node sending you a bugged version of the javascript client.<br /></blockquote><div class="quotefooter"><div class="botslice_quote"></div></div><br />... did I do something to offend you?&nbsp; Perhaps if you read 2 messages down you&#039;d notice that I looked again and decided I was wrong.&nbsp; I&#039;m not entirely sure what your tone is about, friend, but I made a statement; decided I needed to verify my statement because I couldn&#039;t quite remember what led me to the conclusion I came to; did so; decided I was wrong; and corrected it.&nbsp; Perhaps you&#039;d like to tell me what I should have done, other than leaving a question completely unanswered while we all waited for you or astor to show up?<br /><br />If I may indulge in a little bit of back-and-forth, if you will: anyone who says a language isn&#039;t suited to something because of its inherent properties as a language is a fool who pays more attention to standards and stereotypes than reality and truth.&nbsp; Any language that can accomplish something is a perfectly fine language to use for the task.<br /><br />It&#039;s called Gibberish-AES, and in fact I have seen the code.&nbsp; Perhaps it&#039;s you who hasn&#039;t, friend.<br /><br /><br />In fact... you are so full of shit, I am not going to let this stand.&nbsp; Let me dissect your argument piece by piece.<br /><div class="quoteheader"><div class="topslice_quote">Quote</div></div><blockquote class="bbc_standard_quote">Privnote is not anywhere near as secure as GPG. For one they could backdoor the code just like you said. For two you need to transfer the URL in plaintext or encrypt it with GPG, opening it up to massive MITM potential.<br /></blockquote><div class="quotefooter"><div class="botslice_quote"></div></div>The question is in regard to plain text addresses, buddy.&nbsp; End-to-end encrypted within the Tor network.&nbsp; This doesn&#039;t apply.<br /><br /><div class="quoteheader"><div class="topslice_quote">Quote</div></div><blockquote class="bbc_standard_quote">The fact that a message is deleted automatically doesn&#039;t mean jack shit since somebody who does MITM will just intercept , read, make a new message.<br /></blockquote><div class="quotefooter"><div class="botslice_quote"></div></div>Yes, this is true.&nbsp; It also has nothing to do with GPG since GPG doesn&#039;t make the same claim.<br /><br /><div class="quoteheader"><div class="topslice_quote">Quote</div></div><blockquote class="bbc_standard_quote">GPG is for getting around issues like that, privnote doesn&#039;t do jack shit to solve the underlying issues.<br /></blockquote><div class="quotefooter"><div class="botslice_quote"></div></div>Plain text addresses you bloody loon, not the entire fucking universe.<br /><br /><div class="quoteheader"><div class="topslice_quote">Quote</div></div><blockquote class="bbc_standard_quote">Not to mention it is written in javascript, which is hardly the ideal language for doing crypto shit in.<br /></blockquote><div class="quotefooter"><div class="botslice_quote"></div></div>You&#039;re a fucking idiot.&nbsp; Javascript to my knowledge is Turing complete.&nbsp; Someone will fucking write your personality in it someday, I guarantee you.<br /><br /><div class="quoteheader"><div class="topslice_quote">Quote</div></div><blockquote class="bbc_standard_quote">Not to mention you have not even looked at the code so how the hell are you to know if it is secure or not?<br /></blockquote><div class="quotefooter"><div class="botslice_quote"></div></div>Again, Gibberish-AES.&nbsp; Go look it up.<br /><br /><div class="quoteheader"><div class="topslice_quote">Quote</div></div><blockquote class="bbc_standard_quote">Oh not to mention when you use privnote you are weak to your Tor exit node sending you a bugged version of the javascript client.<br /></blockquote><div class="quotefooter"><div class="botslice_quote"></div></div>Here, however, you&#039;re correct.&nbsp; Which I stated initially -- no guarantee that the code will remain secure the moment before you encrypt.&nbsp; Why are you trying to throw my own points back at me?<br /><br />In short: if you want to call someone an idiot, go look in a mirror.
			</dd>
			<dt class="postheader">
				Title: <strong>Re: Plain text addresses </strong><br />
				Post by: <strong>kmfkewm</strong> on <strong>June 18, 2013, 02:31 am</strong>
			</dt>
			<dd class="postbody">
				<div class="quoteheader"><div class="topslice_quote">Quote</div></div><blockquote class="bbc_standard_quote">... did I do something to offend you?&nbsp; <br /></blockquote><div class="quotefooter"><div class="botslice_quote"></div></div><br />No nothing to offend me, it is just annoying to see you constantly going on about things and acting like you fully comprehend them when you clearly don&#039;t while making as many excuses for yourself as possible (&#039;oh I am so tired&#039;, &#039;oh I didn&#039;t even read the full thing&#039;) in case you got something wrong (which you seem to do a lot). How about you read the papers you comment on, read the articles you comment on, read the source code of the program you comment on, and then come to a conclusion. You thought the attack on the implementation of that password safe program was an attack that cut AES key strength in half when it was an attack on the PBKDF, you dismissed Zerocoin as being impossible without even reading the whitepaper, you spoke poorly of the people who wrote the HSDIR attack paper because you confused rendezvous points with introduction points, and now you are saying that Privnote offers security equal to GPG when it obviously doesn&#039;t. So no I am not offended I am just annoyed that you keep spouting off nonsense when you don&#039;t even take the slightest time to research what you are talking about. Once or twice or three times or four times I would let it pass, and I even edited my post in the HSDIR attack thread after originally calling you out, but you consistently engage in spouting off about technical things that you are not understanding. And you do it in the most condescending way half of the time, like the security researchers writing these papers are idiots who don&#039;t know what they are talking about, simultaneously with making excuses for yourself and admitting that you have not even researched what you are commenting on or even finished reading the papers. <br /><br /><br /><div class="quoteheader"><div class="topslice_quote">Quote</div></div><blockquote class="bbc_standard_quote">Perhaps if you read 2 messages down you&#039;d notice that I looked again and decided I was wrong.&nbsp; I&#039;m not entirely sure what your tone is about, friend, but I made a statement; decided I needed to verify my statement because I couldn&#039;t quite remember what led me to the conclusion I came to; did so; decided I was wrong; and corrected it.&nbsp; Perhaps you&#039;d like to tell me what I should have done, other than leaving a question completely unanswered while we all waited for you or astor to show up?<br /></blockquote><div class="quotefooter"><div class="botslice_quote"></div></div><br />You could have said nothing at all if you didn&#039;t know what you were talking about. I don&#039;t even care if people get things wrong, I doubt anybody here is a professional level security expert, but you don&#039;t say things that are wrong you make claims that are wrong. There is a big difference. <br /><br /><div class="quoteheader"><div class="topslice_quote">Quote</div></div><blockquote class="bbc_standard_quote">Privnote actually was -- at least at the time that I looked at it -- just as safe as PGP.</blockquote><div class="quotefooter"><div class="botslice_quote"></div></div><br />This is a false claim. If you had said <br /><br /><div class="quoteheader"><div class="topslice_quote">Quote</div></div><blockquote class="bbc_standard_quote">I think privnote is just as safe as PGP</blockquote><div class="quotefooter"><div class="botslice_quote"></div></div><br />I would have corrected you but not called you out. Hell even if you had just said this alone I wouldn&#039;t have cared, it is just a consistent theme I notice in your posts that has been consistently irritating me. It is okay to be wrong, it is annoying as hell when people consistently make definitive claims that are wrong, even more so when it is due to lack of research or even reading of the entire paper that they are commenting on. 
			</dd>
			<dt class="postheader">
				Title: <strong>Re: Plain text addresses </strong><br />
				Post by: <strong>kmfkewm</strong> on <strong>June 18, 2013, 02:32 am</strong>
			</dt>
			<dd class="postbody">
				<div class="quoteheader"><div class="topslice_quote">Quote</div></div><blockquote class="bbc_standard_quote">If I may indulge in a little bit of back-and-forth, if you will: anyone who says a language isn&#039;t suited to something because of its inherent properties as a language is a fool who pays more attention to standards and stereotypes than reality and truth.&nbsp; Any language that can accomplish something is a perfectly fine language to use for the task.<br /></blockquote><div class="quotefooter"><div class="botslice_quote"></div></div><br />Try again: http://www.matasano.com/articles/javascript-cryptography/<br /><br /><div class="quoteheader"><div class="topslice_quote">Quote</div></div><blockquote class="bbc_standard_quote">What do you mean, &quot;Javascript cryptography&quot;?<br /><br />We mean attempts to implement security features in browsers using cryptographic algoritms implemented in whole or in part in Javascript.<br /><br />You may now be asking yourself, &quot;What about Node.js? What about non-browser Javascript?&quot;. Non-browser Javascript cryptography is perilous, but not doomed. For the rest of this document, we&#039;re referring to browser Javascript when we discuss Javascript cryptography.<br />Why does browser cryptography matter?<br /><br />The web hosts most of the world&#039;s new crypto functionality. A significant portion of that crypto has been implemented in Javascript, and is thus doomed. This is an issue worth discussing.<br />What are some examples of &quot;doomed&quot; browser cryptography?<br /><br />You have a web application. People log in to it with usernames and passwords. You&#039;d rather they didn&#039;t send their passwords in the clear, where attackers can capture them. You could use SSL/TLS to solve this problem, but that&#039;s expensive and complicated. So instead, you create a challenge-response protocol, where the application sends Javascript to user browsers that gets them to send HMAC-SHA1(password, nonce) to prove they know a password without ever transmitting the password.<br /><br />Or, you have a different application, where users edit private notes stored on a server. You&#039;d like to offer your users the feature of knowing that their notes can&#039;t be read by the server. So you generate an AES key for each note, send it to the user&#039;s browser to store locally, forget the key, and let the user wrap and unwrap their data.<br />What&#039;s wrong with these examples?<br /><br />They will both fail to secure users.<br />Really? Why?<br /><br />For several reasons, including the following:<br /><br />&nbsp; &nbsp; Secure delivery of Javascript to browsers is a chicken-egg problem.<br /><br />&nbsp; &nbsp; Browser Javascript is hostile to cryptography.<br /><br />&nbsp; &nbsp; The &quot;view-source&quot; transparency of Javascript is illusory.<br /><br />&nbsp; &nbsp; Until those problems are fixed, Javascript isn&#039;t a serious crypto research environment, and suffers for it.<br /><br />What&#039;s the &quot;chicken-egg problem&quot; with delivering Javascript cryptography?<br /><br />If you don&#039;t trust the network to deliver a password, or, worse, don&#039;t trust the server not to keep user secrets, you can&#039;t trust them to deliver security code. The same attacker who was sniffing passwords or reading diaries before you introduce crypto is simply hijacking crypto code after you do.<br />That attack sounds complicated! Surely, you&#039;re better off with crypto than without it?<br /><br />There are three misconceptions embedded in that common objection, all of them grave.<br /><br />First, although the &quot;hijack the crypto code to steal secrets&quot; attack sounds complicated, it is in fact simple. Any attacker who could swipe an unencrypted secret can, with almost total certainty, intercept and alter a web request. Intercepting requests does not require advanced computer science. Once an attacker controls the web requests, the work needed to fatally wound crypto code is trivial: the attacker need only inject another &lt;SCRIPT&gt; tag to steal secrets before they&#039;re encrypted.<br /><br />Second, the difficulty of an attack is irrelevant. What&#039;s relevant is how tractable the attack is. Cryptography deals in problems that intractable even stipulating an attacker with as many advanced computers as there are atoms composing the planet we live on. On that scale, the difficulty of defeating a cryptosystem delivered over an insecure channel is indistinguishable from &quot;so trivial as to be automatic&quot;. Further perspective: we live and work in an uncertain world in which any piece of software we rely on could be found vulnerable to new flaws at any time. But all those flaws require new R&amp;D effort to discover. Relative to the difficulty of those attacks, against which the industry deploys hundreds of millions of dollars every year, the difficulties of breaking Javascript crypto remain imperceptibly different than &quot;trivial&quot;.<br /><br />Finally, the security value of a crypto measure that fails can easily fall below zero. The most obvious way that can happen is for impressive-sounding crypto terminology to convey a false sense of security. But there are worse ways; for instance, flaws in login crypto can allow attackers to log in without ever knowing a user&#039;s password, or can disclose one user&#039;s documents to another user.<br />Why can&#039;t I use TLS/SSL to deliver the Javascript crypto code?<br /><br />You can. It&#039;s harder than it sounds, but you safely transmit Javascript crypto to a browser using SSL. The problem is, having established a secure channel with SSL, you no longer need Javascript cryptography; you have &quot;real&quot; cryptography. Meanwhile, the Javascript crypto code is still imperiled by other browser problems.<br />What&#039;s hard about deploying Javascript over SSL/TLS?<br /><br />You can&#039;t simply send a single Javascript file over SSL/TLS. You have to send all the page content over SSL/TLS. Otherwise, attackers will hijack the crypto code using the least-secure connection that builds the page.<br />How are browsers hostile to cryptography?<br /><br />In a dispriting variety of ways, among them:<br /><br />&nbsp; &nbsp; The prevalence of content-controlled code.<br /><br />&nbsp; &nbsp; The malleability of the Javascript runtime.<br /><br />&nbsp; &nbsp; The lack of systems programming primitives needed to implement crypto.<br /><br />&nbsp; &nbsp; The crushing weight of the installed base of users.<br /><br />Each of these issues creates security gaps that are fatal to secure crypto. Attackers will exploit them to defeat systems that should otherwise be secure. There may be no way to address them without fixing browsers.<br />What do you mean by &quot;content-controlled code&quot;? Why is it a problem?<br /><br />We mean that pages are built from multiple requests, some of them conveying Javascript directly, and some of them influencing Javascript using DOM tag attributes (such as &quot;onmouseover&quot;).<br />Ok, then I&#039;ll just serve a cryptographic digest of my code from the same server so the code can verify itself.<br /><br />This won&#039;t work.<br /><br />Content-controlled code means you can&#039;t reason about the security of a piece of Javascript without considering every other piece of content that built the page that hosted it. A crypto routine that is completely sound by itself can be utterly insecure hosted on a page with a single, invisible DOM attribute that backdoors routines that the crypto depends on.<br /><br />This isn&#039;t an abstract problem. It&#039;s an instance of &quot;Javascript injection&quot;, better known to web developers as &quot;cross-site scripting&quot;. Virtually every popular web application ever deployed has fallen victim to this problem, and few researchers would take the other side of a bet that most will again in the future.<br /><br />Worse still, browsers cache both content and Javascript aggressively; caching is vital to web performance. Javascript crypto can&#039;t control the caching behavior of the whole browser with specificity, and for most applications it&#039;s infeasible to entirely disable caching. This means that unless you can create a &quot;clean-room&quot; environment for your crypto code to run in, pulling in no resource tainted by any other site resource (from layout to UX) , you can&#039;t even know what version of the content you&#039;re looking at.<br />What&#039;s a &quot;malleable runtime&quot;? Why are they bad?<br /><br />We mean you can change the way the environment works at runtime. And it&#039;s not bad; it&#039;s a fantastic property of a programming environment, particularly one used &quot;in the small&quot; like Javascript often is. But it&#039;s a real problem for crypto.<br /><br />The problem with running crypto code in Javascript is that practically any function that the crypto depends on could be overridden silently by any piece of content used to build the hosting page. Crypto security could be undone early in the process (by generating bogus random numbers, or by tampering with constants and parameters used by algorithms), or later (by spiriting key material back to an attacker), or --- in the most likely scenario --- by bypassing the crypto entirely.<br /><br />There is no reliable way for any piece of Javascript code to verify its execution environment. Javascript crypto code can&#039;t ask, &quot;am I really dealing with a random number generator, or with some facsimile of one provided by an attacker?&quot; And it certainly can&#039;t assert &quot;nobody is allowed to do anything with this crypto secret except in ways that I, the author, approve of&quot;. These are two properties that often are provided in other environments that use crypto, and they&#039;re impossible in Javascript.<br />Well then, couldn&#039;t I write a simple browser extension that would allow Javascript to verify itself?<br /><br />You could. It&#039;s harder than it sounds, because you&#039;d have to verify the entire runtime, including anything the DOM could contribute to it, but it is theoretically possible. But why would you ever do that? If you can write a runtime verifier extension, you can also do your crypto in the extension, and it&#039;ll be far safer and better.<br /><br />&quot;But&quot;, you&#039;re about to say, &quot;I want my crypto to be flexible! I only want the bare minimum functionality in the extension!&quot; This is a bad thing to want, because ninety-nine and five-more-nines percent of the crypto needed by web applications would be entirely served by a simple, well-specified cryptosystem: PGP.<br /><br />The PGP cryptosystem is approaching two decades of continuous study. Just as all programs evolve towards a point where they can read email, and all languages contain a poorly-specified and buggy implementation of Lisp, most crypto code is at heart an inferior version of PGP. PGP sounds complicated, but there is no reason a browser-engine implementation would need to be (for instance, the web doesn&#039;t need all the keyring management, the &quot;web of trust&quot;, or the key servers). At the same time, much of what makes PGP seem unwieldy is actually defending against specific, dangerous attacks.<br />You want my browser to have my PGP key?<br /><br />Definitely not. It&#039;d be nice if your browser could generate, store, and use its own PGP keys though.<br />What systems programming functionality does Javascript lack?<br /><br />Here&#039;s a starting point: a secure random number generator.<br />How big a deal is the random number generator?<br /><br />Virtually all cryptography depends on secure random number generators (crypto people call them CSPRNGs). In most schemes, the crypto keys themselves come from a CSPRNG. If your PRNG isn&#039;t CS, your scheme is no longer cryptographically secure; it is only as secure as the random number generator.<br />But how easy is it to attack an insecure random generator, really?<br /><br />It&#039;s actually hard to say, because in real cryptosystems, bad RNGs are a &quot;hair on fire&quot; problem solved by providing a real RNG. Some RNG schemes are pencil-and-paper solveable; others are &quot;crackable&quot;, like an old DES crypt(3) password. It depends on the degree of badness you&#039;re willing to accept. But: no SSL system would accept any degree of RNG badness.<br />But I can get random numbers over the Internet and use them for my crypto!<br /><br />How can you do that without SSL? And if you have SSL, why do you need Javascript crypto? Just use the SSL.<br />I&#039;ll use RANDOM.ORG. They support SSL.<br /><br />â€œJavascript Cryptography. It&#039;s so bad, youâ€™ll consider making async HTTPS requests to RANDOM.ORG simply to fetch random numbers.&quot;<br /></blockquote><div class="quotefooter"><div class="botslice_quote"></div></div>
			</dd>
			<dt class="postheader">
				Title: <strong>Re: Plain text addresses </strong><br />
				Post by: <strong>kmfkewm</strong> on <strong>June 18, 2013, 02:33 am</strong>
			</dt>
			<dd class="postbody">
				continued ....<br /><br /><div class="quoteheader"><div class="topslice_quote">Quote</div></div><blockquote class="bbc_standard_quote">Imagine a system that involved your browser encrypting something, but filing away a copy of the plaintext and the key material with an unrelated third party on the Internet just for safekeeping. That&#039;s what this solution amounts to. You can&#039;t outsource random number generation in a cryptosystem; doing so outsources the security of the system.<br />What else is the Javascript runtime lacking for crypto implementors?<br /><br />Two big ones are secure erase (Javascript is usually garbage collected, so secrets are lurking in memory potentially long after they&#039;re needed) and functions with known timing characteristics. Real crypto libraries are carefully studied and vetted to eliminate data-dependant code paths --- ensuring that one similarly-sized bucket of bits takes as long to process as any other --- because without that vetting, attackers can extract crypto keys from timing.<br />But other languages have the same problem!<br /><br />That&#039;s true. But what&#039;s your point? We&#039;re not saying Javascript is a bad language. We&#039;re saying it doesn&#039;t work for crypto inside a browser.<br />But people rely on crypto in languages like Ruby and Java today. Are they doomed, too?<br /><br />Some of them are; crypto is perilous.<br /><br />But many of them aren&#039;t, because they can deploy countermeasures that Javascript can&#039;t. For instance, a web app developer can hook up a real CSPRNG from the operating system with an extension library, or call out to constant-time compare functions.<br /><br />If Python was the standard browser content programming language, browser Python crypto would also be doomed.<br />What else is Javascript missing?<br /><br />A secure keystore.<br />What&#039;s that?<br /><br />A way to generate and store private keys that doesn&#039;t depend on an external trust anchor.<br />External what now?<br /><br />It means, there&#039;s no way to store a key securely in Javascript that couldn&#039;t be expressed with the same fundamental degree of security by storing the key on someone else&#039;s server.<br />Wait, can&#039;t I generate a key and use it to secure things in HTML5 local storage? What&#039;s wrong with that?<br /><br />That scheme is, at best, only as secure as the server that fed you the code you used to secure the key. You might as well just store the key on that server and ask for it later. For that matter, store your documents there, and keep the moving parts out of the browser.<br />These don&#039;t seem like earth-shattering problems. We&#039;re so close to having what we need in browsers, why not get to work on it?<br /><br />Check back in 10 years when the majority of people aren&#039;t running browsers from 2008.<br />That&#039;s the same thing people say about web standards.<br /><br />Compare downsides: using Arial as your typeface when you really wanted FF Meta, or coughing up a private key for a crypto operation.<br /><br />We&#039;re not being entirely glib. Web standards advocates care about graceful degradation, the idea that a page should at least be legible even if the browser doesn&#039;t understand some advanced tag or CSS declaration.<br /><br />&quot;Graceful degradation&quot; in cryptography would imply that the server could reliably identify which clients it could safely communicate with, and fall back to some acceptable substitute in cases where it couldn&#039;t. The former problem is unsolved even in the academic literature. The latter recalls the chicken-egg problem of web crypto: if you have an acceptable lowest-common-denominator solution, use that instead.<br />This is what you meant when you referred to the &quot;crushing burden of the installed base&quot;?<br /><br />Yes.<br />And when you said &quot;view-source transparency was illusory&quot;?<br /><br />We meant that you can&#039;t just look at a Javascript file and know that it&#039;s secure, even in the vanishingly unlikely event that you were a skilled cryptographer, because of all the reasons we just cited.<br />Nobody verifies the software they download before they run it. How could this be worse?<br /><br />Nobody installs hundreds of applications every day. Nobody re-installs each application every time they run it. But that&#039;s what people are doing, without even realizing it, with web apps.<br /><br />This is a big deal: it means attackers have many hundreds of opportunities to break web app crypto, where they might only have one or two opportunities to break a native application.<br />But people give their credit cards to hundreds of random people insecurely.<br /><br />An attacker can exploit a flaw in a web app across tens or hundreds of thousands of users at one stroke. They can&#039;t get a hundred thousand credit card numbers on the street.<br />You&#039;re just not going to give an inch on this, are you?<br /><br />Nobody would accept any of the problems we&#039;re dredging up here in a real cryptosystem. If SSL/TLS or PGP had just a few of these problems, it would be front-page news in the trade press.<br />You said Javascript crypto isn&#039;t a serious research area.<br /><br />It isn&#039;t.<br />How much research do we really need? We&#039;ll just use AES and SHA256. Nobody&#039;s talking about inventing new cryptosystems.<br /><br />AES is to &quot;secure cryptosystems&quot; what uranium oxide pellets are to &quot;a working nuclear reactor&quot;. Ever read the story of the radioactive boy scout? He bought an old clock with painted with radium and found a vial of radium paint inside. Using that and a strip of beryllium swiped from his high school chemistry lab, he built a radium gun that irradiated pitchblende. He was on his way to building a &quot;working breeder reactor&quot; before moon-suited EPA officials shut him down and turned his neighborhood into a Superfund site.<br /><br />The risks in building cryptography directly out of AES and SHA routines are comparable. It is capital-H Hard to construct safe cryptosystems out of raw algorithms, which is why you generally want to use high-level constructs like PGP instead of low-level ones.<br />What about things like SJCL, the Stanford crypto library?<br /><br />SJCL is great work, but you can&#039;t use it securely in a browser for all the reasons we&#039;ve given in this document.<br /><br />SJCL is also practically the only example of a trustworthy crypto library written in Javascript, and it&#039;s extremely young.<br /><br />The authors of SJCL themselves say, &quot;Unfortunately, this is not as great as in desktop applications because it is not feasible to completely protect against code injection, malicious servers and side-channel attacks.&quot; That last example is a killer: what they&#039;re really saying is, &quot;we don&#039;t know enough about Javascript runtimes to know whether we can securely host cryptography on them&quot;. Again, that&#039;s painful-but-tolerable in a server-side application, where you can always call out to native code as a workaround. It&#039;s death to a browser.<br />Aren&#039;t you creating a self-fulfilling prophecy about Javascript crypto research?<br /><br />People don&#039;t take Javascript crypto seriously because they can&#039;t get past things like &quot;there&#039;s no secure way to key a cryptosystem&quot; and &quot;there&#039;s no reliably safe way to deliver the crypto code itself&quot; and &quot;there&#039;s practically no value to doing crypto in Javascript once you add SSL to the mix, which you have to do to deliver the code&quot;.<br />These may be real problems, but we&#039;re talking about making crypto available to everyone on the Internet. The rewards outweigh the risks!<br /><br />DETROIT --- A man who became the subject of a book called &quot;The Radioactive Boy Scout&quot; after trying to build a nuclear reactor in a shed as a teenager has been charged with stealing 16 smoke detectors. Police say it was a possible effort to experiment with radioactive materials.<br /><br />The world works the way it works, not the way we want it to work. It&#039;s one thing to point at the flaws that make it hard to do cryptography in Javascript and propose ways to solve them; it&#039;s quite a different thing to simply wish them away, which is exactly what you do when you deploy cryptography to end-users using their browser&#039;s Javascript runtime.<br /></blockquote><div class="quotefooter"><div class="botslice_quote"></div></div>
			</dd>
			<dt class="postheader">
				Title: <strong>Re: Plain text addresses </strong><br />
				Post by: <strong>kmfkewm</strong> on <strong>June 18, 2013, 02:34 am</strong>
			</dt>
			<dd class="postbody">
				<div class="quoteheader"><div class="topslice_quote">Quote</div></div><blockquote class="bbc_standard_quote"><div class="quoteheader"><div class="topslice_quote">Quote</div></div><blockquote class="bbc_alternate_quote">Privnote is not anywhere near as secure as GPG. For one they could backdoor the code just like you said. For two you need to transfer the URL in plaintext or encrypt it with GPG, opening it up to massive MITM potential.<br /></blockquote><div class="quotefooter"><div class="botslice_quote"></div></div>The question is in regard to plain text addresses, buddy.&nbsp; End-to-end encrypted within the Tor network.&nbsp; This doesn&#039;t apply.<br /></blockquote><div class="quotefooter"><div class="botslice_quote"></div></div><br />Lol are you kidding me? Why the fuck even use privnote if the end to end encryption of Tor is enough to protect you? Do you understand the difference between link encryption and message encryption? Just because Tor hidden services use end to end encrypted links doesn&#039;t mean that the message is encrypted when it is stored on the server. That is the reason why we use GPG, to add message encryption as well. So that when the message is sitting on the server it cannot be intercepted and decrypted. When a privnote link is sitting on the server it can be intercepted and the message can be obtained. So it is completely worthless for our purposes. Privnote symmetrically encrypts the message and then you hand out the symmetric key without using an asymmetric algorithm for session key transfer. I might as well AES encrypt a message to the vendor and send them the password to decrypt it along with the ciphertext. That is what privnote is doing. It isn&#039;t even the same thing as GPG, which is a hybrid cryptosystem. Privnote is a retarded implementation of a symmetric encryption algorithm that they are tricking idiots into using instead of an asymmetric-symmetric cryptosystem like GPG.<br /><br />It would be nice if you had a basic understanding of the fundamentals of cryptography prior to trying to argue with me. <br /><br /><div class="quoteheader"><div class="topslice_quote">Quote</div></div><blockquote class="bbc_standard_quote"><div class="quoteheader"><div class="topslice_quote">Quote</div></div><blockquote class="bbc_alternate_quote">The fact that a message is deleted automatically doesn&#039;t mean jack shit since somebody who does MITM will just intercept , read, make a new message.<br /></blockquote><div class="quotefooter"><div class="botslice_quote"></div></div>Yes, this is true.&nbsp; It also has nothing to do with GPG since GPG doesn&#039;t make the same claim.<br /></blockquote><div class="quotefooter"><div class="botslice_quote"></div></div><br />It has everything to do with GPG because if I send a vendor a message encrypted with GPG the attacker can not read my message but if I send the vendor a privnote message the attacker can read my message and then replace it such that the vendor never knows the message was read. That means that Privnote has 0 security, it accomplishes jack fucking shit. I send the vendor a link to a symmetrically encrypted message and in plaintext I send them the symmetric key, so obviously the encryption isn&#039;t helping a god damn thing. That means the security of the system entirely depends on privnote deleting messages after they are read once, so the vendor can tell if their message was intercepted, but oh the MITM attacker can just recreate the same exact message and send the vendor the new link. So Privnote accomplishes absolutely nothing at all, GPG accomplishes something. <br /><br /><div class="quoteheader"><div class="topslice_quote">Quote</div></div><blockquote class="bbc_standard_quote"><div class="quoteheader"><div class="topslice_quote">Quote</div></div><blockquote class="bbc_alternate_quote">GPG is for getting around issues like that, privnote doesn&#039;t do jack shit to solve the underlying issues.<br /></blockquote><div class="quotefooter"><div class="botslice_quote"></div></div>Plain text addresses you bloody loon, not the entire fucking universe.<br /></blockquote><div class="quotefooter"><div class="botslice_quote"></div></div><br />I don&#039;t even understand what the hell you are talking about here??<br /><br /><br /><div class="quoteheader"><div class="topslice_quote">Quote</div></div><blockquote class="bbc_standard_quote"><div class="quoteheader"><div class="topslice_quote">Quote</div></div><blockquote class="bbc_alternate_quote">Not to mention it is written in javascript, which is hardly the ideal language for doing crypto shit in.<br /></blockquote><div class="quotefooter"><div class="botslice_quote"></div></div>You&#039;re a fucking idiot.&nbsp; Javascript to my knowledge is Turing complete.&nbsp; Someone will fucking write your personality in it someday, I guarantee you.<br /></blockquote><div class="quotefooter"><div class="botslice_quote"></div></div><br />Ho hum, can javascript even do constant time operations. Get a clue before making claims plz. <br /><br /><br /><div class="quoteheader"><div class="topslice_quote">Quote</div></div><blockquote class="bbc_standard_quote"><div class="quoteheader"><div class="topslice_quote">Quote</div></div><blockquote class="bbc_alternate_quote">Not to mention you have not even looked at the code so how the hell are you to know if it is secure or not?<br /></blockquote><div class="quotefooter"><div class="botslice_quote"></div></div>Again, Gibberish-AES.&nbsp; Go look it up.<br /></blockquote><div class="quotefooter"><div class="botslice_quote"></div></div><br />You are the one who said you never looked at the code in the first place. Anyway AES implemented in javascript is not likely to be very secure. <br /><br /><div class="quoteheader"><div class="topslice_quote">Quote</div></div><blockquote class="bbc_standard_quote"><div class="quoteheader"><div class="topslice_quote">Quote</div></div><blockquote class="bbc_alternate_quote">Oh not to mention when you use privnote you are weak to your Tor exit node sending you a bugged version of the javascript client.<br /></blockquote><div class="quotefooter"><div class="botslice_quote"></div></div>Here, however, you&#039;re correct.&nbsp; Which I stated initially -- no guarantee that the code will remain secure the moment before you encrypt.&nbsp; Why are you trying to throw my own points back at me?<br /><br />In short: if you want to call someone an idiot, go look in a mirror.<br /></blockquote><div class="quotefooter"><div class="botslice_quote"></div></div><br /><br />Your initial statement was that GPG and Privnote are of equal security, and I never called anyone an idiot but you did just clarify for me that you are one. 
			</dd>
			<dt class="postheader">
				Title: <strong>Re: Plain text addresses </strong><br />
				Post by: <strong>kmfkewm</strong> on <strong>June 18, 2013, 03:18 am</strong>
			</dt>
			<dd class="postbody">
				http://rdist.root.org/2010/11/29/final-post-on-javascript-crypto/<br /><br /><div class="quoteheader"><div class="topslice_quote">Quote</div></div><blockquote class="bbc_standard_quote">The talk I gave last year on common crypto flaws still seems to generate comments. The majority of the discussion is by defenders of Javascript crypto. I made JS crypto a very minor part of the talk because I thought it would be obvious why it is a bad idea. Apparently, I was wrong to underestimate the grip it seems to have on web developers.<br /><br />Rather than repeat the same rebuttals over and over, this is my final post on this subject. It ends with a challenge — if you have an application where Javascript crypto is more secure than traditional implementation approaches, post it in the comments. I’ll write a post citing you and explaining how you changed my mind. But since I expect this to be my last post on the matter, read this article carefully before posting.<br /><br />To illustrate the problems with JS crypto, let’s use a simplified example application: a secure note-taker. The user writes notes to themselves that they can access from multiple computers. The notes will be encrypted by a random key, which is itself encrypted with a key derived from a passphrase. There are three implementation approaches we will consider: traditional client-side app, server-side app, and Javascript crypto. We will ignore attacks that are common to all three implementations (e.g., weak passphrase, client-side keylogger) and focus on their differences.<br /><br />The traditional client-side approach offers the most security. For example, you could wrap PGP in a GUI with a notes field and store the encrypted files and key on the server. A client who is using the app is secure against future compromise of the server. However, they are still at risk of buggy or trojaned code each time they download the code. If they are concerned about this kind of attack, they can store a local copy and have a cryptographer audit it before using it.<br /><br />The main advantage to this approach is that PGP has been around almost 20 years. It is well-tested and the GUI author is unlikely to make a mistake in interfacing with it (especially if using GPGME). The code is open-source and available for review.<br /><br />If you don’t want to install client-side code, a less-secure approach is a server-side app accessed via a web browser. To take advantage of existing crypto code, we’ll use PGP again but the passphrase will be sent to it via HTTP and SSL. The server-side code en/decrypts the notes using GPGME and pipes the results to the user.<br /><br />Compared to client-side code, there are a number of obvious weaknesses. The passphrase can be grabbed from the memory of the webserver process each time it is entered. The PGP code can be trojaned, possibly in a subtle way. The server’s /dev/urandom can be biased, weakening any keys generated there.<br /><br />The most important difference from a client-side attack is that it takes effect immediately. An attacker who trojans a client app has to wait until users download and start using it. They can copy the ciphertext from the server, but it isn’t accessible until someone runs their trojan, exposing their passphrase or key. However, a server-side trojan takes effect immediately and all users who access their notes during this time period are compromised.<br /><br />Another difference is that the password is exposed to a longer chain of software. With a client-side app, the passphrase is entered into the GUI app and passed over local IPC to PGP. It can be wiped from RAM after use, protected from being swapped to disk via mlock(), and generally remains under the user’s control. With the server-side app, it is entered into a web browser (which can cache it), sent over HTTPS (which involves trusting hundreds of CAs and a complex software stack), hits a webserver, and is finally passed over local IPC to PGP. A compromise of any component of that chain exposes the password.<br /><br />The last difference is that the user cannot audit the server to see if an attack has occurred. With client-side code, the user can take charge of change management, refusing to update to new code until it can be audited. With a transport-level attack (e.g., sslstrip), there is nothing to audit after the fact.<br /><br />The final implementation approach is Javascript crypto. The trust model is similar to server-side crypto except the code executes in the user’s browser instead of on the server. For our note-taker app, the browser would receive a JS crypto library over HTTPS. The first time it is used, it generates the user’s encryption key and encrypts it with the passphrase (say, derived via PBKDF2). This encrypted key is persisted on the server. The notes files are en/decrypted by the JS code before being sent to the server.<br /><br />Javascript crypto has all the same disadvantages as server-side crypto, plus more. A slightly modified version of all the server-side attacks still works. Instead of trojaning the server app, an attacker can trojan the JS that is sent to the user. Any changes to the code immediately take effect for all active users. There’s the same long chain of software having access to critical data (JS code and the password processed by it).<br /><br />So what additional problems make JS crypto worse than the server-side approach?<br /><br />&nbsp; &nbsp; Numerous libraries not maintained by cryptographers — With a little searching, I found: clipperz, etherhack, Titaniumcore, Dojo, crypto-js, jsSHA, jscryptolib, pidCrypt, van Everdingen’s library, and Movable Type’s AES. All not written or maintained by cryptographers. One exception is Stanford SJCL, although that was written by grad students 6 months ago so it’s too soon to tell how actively tested/maintained it will be.<br />&nbsp; &nbsp; New code has not been properly reviewed and no clear “best practices” for implementers — oldest library I can find is 2 years old. Major platform-level questions still need to be resolved by even the better ones.<br />&nbsp; &nbsp; Low-level primitives only — grab bag of AES, Serpent, RC4, and Caesar ciphers (yes, in same library). No high-level operations like GPGME. Now everyone can (and has to) be a crypto protocol designer.<br />&nbsp; &nbsp; Browser is low-assurance environment — same-origin policy is not a replacement for ACLs, privilege separation, memory protection, mlock(), etc. JS DOM allows arbitrary eval on each element and language allows rebinding most operations (too much flexibility for crypto).<br />&nbsp; &nbsp; Poor crypto support — JS has no secure PRNG such as /dev/urandom, side channel resistance is much more difficult if not impossible<br />&nbsp; &nbsp; Too many platforms — IE, Firefox, Netscape, Opera, WebKit, Konqueror, and all versions of each. Crypto code tends to fail catastrophically in the face of platform bugs.<br />&nbsp; &nbsp; Auditability — each user is served a potentially differing copy of the code. Old code may be running due to browser cache issues. Impossible for server maintainers to audit clients.<br /><br />JS crypto is not even better for client-side auditability. Since JS is quite lenient in allowing page elements to rebind DOM nodes, even “View Source” does not reveal the actual code running in the browser. You’re only as secure as the worst script run from a given page or any other pages it allows via document.domain.<br /><br />I have only heard of one application of JS crypto that made sense, but it wasn’t from a security perspective. A web firm processes credit card numbers. For cost reasons, they wanted to avoid PCI audits of their webservers, but PCI required any server that handled plaintext credit card numbers to be audited. So, their webservers send a JS crypto app to the browser client to encrypt the credit card number with an RSA public key. The corresponding private key is accessible only to the backend database. So based on the wording of PCI, only the database server requires an audit.<br /><br />Of course, this is a ludicrous argument from a security perspective. The webserver is a critical part of the chain of trust in protecting the credit card numbers. There are many subtle ways to trojan RSA encryption code to disclose the plaintext. To detect trojans, the web firm has a client machine that repeatedly downloads and checksums the JS code from each webserver. But an attacker can serve the original JS to that machine while sending trojaned code to other users.<br /><br />While I agree this is a clever way to avoid PCI audits, it does not increase actual security in any way. It is still subject to the above drawbacks of JS crypto.<br /><br />If you’ve read this article and still think JS crypto has security advantages over server-side crypto for some particular application, describe it in a comment below. But the burden of proof is on you to explain why the above list of drawbacks is addressed or not relevant to your system. Until then, I am certain JS crypto does not make security sense.<br /><br />Just because something can be done doesn’t mean it should be.<br />Epilogue<br />Auditability of client-side Javascript<br /><br />I had overstated the auditability of JS in the browser environment by saying the code was accessible via “View Source”. It turns out the browser environment is even more malleable than I first thought. There is no user-accessible menu that tells what code is actually executing on a given page since DOM events can cause rebinding of page elements, including your crypto code. Thanks to Thomas Ptacek for pointing this out. I updated the corresponding paragraph above.<br /><br />JS libraries such as jQuery, Prototype, and YUI all have APIs for loading additional page elements, which can be HTML or JS. These elements can rebind DOM nodes, meaning each AJAX query can result in the code of a page changing, not just the data displayed. The APIs don’t make a special effort to filter out page elements, and instead trust that you know what you’re doing.<br /><br />The same origin policy is the only protection against this modification. However, this policy is applied at the page level, not script level. So if any script on a given page sets document.domain to a “safe” value like “example.net”, this would still allow JS code served from “ads.example.net” to override your crypto code on “www.example.net”. Your page is only as secure as the worst script loaded from it.<br /><br />Brendan Eich made an informative comment on how document.domain is not the worst issue, separation of privileges for cross-site scripts is:<br /><br />&nbsp; &nbsp; Scripts can be sourced cross-site, so you could get jacked without document.domain entering the picture just by &lt;script src=”evil.ads.com”&gt;. This threat is real but it is independent of document.domain and it doesn’t make document.domain more hazardous. It does not matter where the scripts come from. They need not come from ads.example.net — if http://www.example.net HTML loads them, they’re #include’d into http://www.example.net’s origin (whether it has been modified by document.domain or not).<br /><br />&nbsp; &nbsp; In other words, if you have communicating pages that set document.domain to join a common superdomain, they have to be as careful with cross-site scripts as a single page loaded from that superdomain would. This suggests that document.domain is not the problem — cross-site scripts having full rights is the problem. See my W2SP 2009 slides.<br /><br />“Proof of work” systems<br /><br />Daniel Franke suggested one potentially-useful application for JS crypto: “proof of work” systems. These systems require the client to compute some difficult function to increase the effort required to send spam, cause denial of service, or bruteforce passwords. While I agree this application would not be subject to the security flaws listed in this article, it would have other problems.<br /><br />Javascript is many times slower than native code and much worse for crypto functions than general computation. This means the advantage an attacker has in creating a native C plus GPU execution environment will likely far outstrip any slowness legitimate users will accept. If the performance ratio between attacker and legitimate users is too great, Javascript can’t be used for this purpose.<br /><br />He recognized this problem and also suggested two ways to address it: increase the difficulty of the work function only when an attack is going on or only for guesses with weak passphrases. The problem with the first is that an attacker can scale up their guessing rate until the server slows down and then stay just below that threshold. Additionally, she can parallelize guesses for multiple users, depending on what the server uses for rate-limiting. One problem with the second is that it adds a round-trip where the server has to see the length of the attacker’s guess before selecting a difficulty for the proof-of-work function. In general, it’s better to select a one-size-fits-all parameter than to try to dynamically scale.<br />Browser plugin can checksum JS crypto code<br /><br />This idea helps my argument, not hurts it. If you can deploy a custom plugin to clients, why not run the crypto there? If it can access the host environment, it has a real PRNG, crypto library (Mozilla NSS or Microsoft CryptoAPI), etc. Because of Javascript’s dynamism, no one knows a secure way to verify signatures on all page elements and DOM updates, so a checksumming plugin would not live up to its promise.<br /></blockquote><div class="quotefooter"><div class="botslice_quote"></div></div>
			</dd>
			<dt class="postheader">
				Title: <strong>Re: Plain text addresses </strong><br />
				Post by: <strong>SelfSovereignty</strong> on <strong>June 18, 2013, 03:35 am</strong>
			</dt>
			<dd class="postbody">
				Alright I lied, I&#039;m not done.&nbsp; This anger and these insults are unbecoming, and I would like to apologize for them.&nbsp; Here is my calm response:<br /><br />I did not intend to ever, at any time, state that Privnote is universally as secure as PGP encryption.&nbsp; If that is what you believe I meant, then you were absolutely correct in making sure to point out I was wrong.&nbsp; If what I said sounded like I really meant that, then some of the fault is indeed with me.&nbsp; That statement is a false one.<br /><br />Again, I didn&#039;t mean to say that.&nbsp; Now is there anything you would like to continue arguing about?&nbsp; Because I believe that is the root of this disagreement, and whether you like me or I like you aside, I believe that the discussion is done.&nbsp; I am, however, here and willing to participate in it further if you desire.&nbsp; So: are we done?
			</dd>
			<dt class="postheader">
				Title: <strong>Re: Plain text addresses </strong><br />
				Post by: <strong>kmfkewm</strong> on <strong>June 18, 2013, 04:19 am</strong>
			</dt>
			<dd class="postbody">
				<div class="quoteheader"><div class="topslice_quote"><a href="http://dkn255hz262ypmii.onion/index.php?topic=173262.msg1248658#msg1248658">Quote from: SelfSovereignty on June 18, 2013, 03:35 am</a></div></div><blockquote class="bbc_standard_quote">... you are a fucking... retard.&nbsp; I mean you really are like some fucking idiot savant pedophile, aren&#039;t you? <br /></blockquote><div class="quotefooter"><div class="botslice_quote"></div></div><br />I pretty openly admit that I am mildly autistic, with traits of savantism, in addition to being non-exclusively ephebephilic, which is colloquially considered to be pedophilia in a minority of the world. If you meant that as an insult to me it didn&#039;t really come across as such.&nbsp; <br /><br /><div class="quoteheader"><div class="topslice_quote">Quote</div></div><blockquote class="bbc_standard_quote">1. I do not know more about cryptography than you do.&nbsp; You know more about it than me.&nbsp; I freely admit that.</blockquote><div class="quotefooter"><div class="botslice_quote"></div></div><br />I am not trying to compete with you. Mostly I am trying to get you to start reading things through before you comment on them. This was the straw that broke the camels back for me. It was also the most insidious of your misconceptions, if you think Zerocoin is impossible it doesn&#039;t really matter, but when people hear a respected member of the community say that Privnote is just as safe as GPG it leads to very real insecure practices. <br /><br /><div class="quoteheader"><div class="topslice_quote">Quote</div></div><blockquote class="bbc_standard_quote">2. In the real world, my friend, you have tasks that need to be accomplished.&nbsp; To say a tool is unsuited to a task when it can accomplish it is blind idiocy.&nbsp; To say it is NOT THE BEST tool for the job is perfectly rational, but it is what goes into that conclusion that matters.&nbsp; WHO GIVES A FUCK IF JAVASCRIPT IS SLOW AND INEFFICIENT AND FUCKING BLOWS TO WRITE?!&nbsp; Does it get the job done -- yes?&nbsp; Then who gives a fuck -- other than you, nobody sane should.<br /></blockquote><div class="quotefooter"><div class="botslice_quote"></div></div><br />You are not comprehending the problems with javascript. Javascript being slow doesn&#039;t matter, javascript not being able to carry out operations in fixed units of time makes it unsuitable for cryptography. Javascript can not accomplish a secure implementation of a cryptographic algorithm. You can implement AES to specification in javascript, but the fact that it is implemented in javascript will make it an insecure implementation even if it perfectly follows the specification. The articles I linked to also point out a variety of other issues, ranging from lack of secure CSPRNG, lack of ability to protect from MITM attacks, etc. Javascript crypto is death by a million side channel attacks. I don&#039;t even claim to be a professional cryptographer, because I am not one. I know enough to implement some basic block ciphers, pseudorandom number generators, etc, but I sure as hell cannot design something like AES or even implement something like AES. But I listen to professional cryptographers, and the thing I always hear from them is that javascript and cryptography do not mix. Interpreted languages and cryptography do not mix. You can end up with something that looks like it works, and something that follows the specification, but the inherent weaknesses of the languages run time environment will side channel the shit out of the cryptosystem. Browser based javascript is even worse, in addition to having all of the problems of javascript it also has the weaknesses to MITM etc that come from it being browser based. <br /><br />So to answer your question: professional cryptographers give a fuck. The people who don&#039;t seem to give a fuck are people who know how to program in javascript and write web applications, but who have absolutely zero education in programming cryptographically secure applications. It seems everybody who knows how to program thinks that they are inherently a cryptographer because of it. <br /><br /><br /><div class="quoteheader"><div class="topslice_quote">Quote</div></div><blockquote class="bbc_standard_quote">This is fucking pointless, I&#039;m not going to itemize pages and pages and pages that have NOTHING TO DO with what I said.&nbsp; No one in their right mind would claim Javascript is BETTER than any other language for crypto.&nbsp; But how many languages does EVERY FUCKING BROWSER in the world implement?&nbsp; Javascript is about the only fucking one.&nbsp; Therefore it was the right tool for the job of Privnote.&nbsp; I don&#039;t understand why you don&#039;t get that or why the fuck you would try to argue about it?&nbsp; I mean you do understand how browsers and interpreters work... right?<br /></blockquote><div class="quotefooter"><div class="botslice_quote"></div></div><br />You are the one who clearly doesn&#039;t understand how interpreters work, and how that is contradictory to the goals of cryptographically secure programming.&nbsp; Privnote is an extremely poorly designed cryptosystem that was written in a language that shouldn&#039;t be used for implementing cryptographic algorithms in, in the worst way they could have used the language to implement their broken system. I do understand that javascript was the &#039;right tool&#039; for the job of Privnote, but what you don&#039;t seem to understand is that the right tool can sometimes make the wrong product. A hammer is the right tool to make a wooden box with, it doesn&#039;t mean you should build a wooden box with a hammer and then try to use it as a submarine. It also doesn&#039;t mean that you can build a submarine with a hammer. <br /><br /><div class="quoteheader"><div class="topslice_quote">Quote</div></div><blockquote class="bbc_standard_quote">You are a truly pathetic little man, my friend.&nbsp; I sincerely hope you enjoy your life.&nbsp; I really do.&nbsp; And with that I am done.<br /></blockquote><div class="quotefooter"><div class="botslice_quote"></div></div><br />k thanks 
			</dd>
			<dt class="postheader">
				Title: <strong>Re: Plain text addresses </strong><br />
				Post by: <strong>SelfSovereignty</strong> on <strong>June 18, 2013, 04:22 am</strong>
			</dt>
			<dd class="postbody">
				I am pasting the modification to my post which you clearly did not read.&nbsp; Please respond to it, and only it, because again, you are arguing against points which are not ones I meant to make.<br /><br /><div class="quoteheader"><div class="topslice_quote">Quote from: me</div></div><blockquote class="bbc_standard_quote">Alright I lied, I&#039;m not done.&nbsp; This anger and these insults are unbecoming, and I would like to apologize for them.&nbsp; Here is my calm response:<br /><br />I did not intend to ever, at any time, state that Privnote is universally as secure as PGP encryption.&nbsp; If that is what you believe I meant, then you were absolutely correct in making sure to point out I was wrong.&nbsp; If what I said sounded like I really meant that, then some of the fault is indeed with me.&nbsp; That statement is a false one.<br /><br />Again, I didn&#039;t mean to say that.&nbsp; Now is there anything you would like to continue arguing about?&nbsp; Because I believe that is the root of this disagreement, and whether you like me or I like you aside, I believe that the discussion is done.&nbsp; I am, however, here and willing to participate in it further if you desire.&nbsp; So: are we done?<br /></blockquote><div class="quotefooter"><div class="botslice_quote"></div></div>
			</dd>
			<dt class="postheader">
				Title: <strong>Re: Plain text addresses </strong><br />
				Post by: <strong>kmfkewm</strong> on <strong>June 18, 2013, 04:37 am</strong>
			</dt>
			<dd class="postbody">
				<div class="quoteheader"><div class="topslice_quote">Quote from: me</div></div><blockquote class="bbc_standard_quote">Alright I lied, I&#039;m not done.&nbsp; This anger and these insults are unbecoming, and I would like to apologize for them.&nbsp; Here is my calm response:<br /></blockquote><div class="quotefooter"><div class="botslice_quote"></div></div><br />I also would like to point out that I am not angry at you, and that insulting you was not my primary goal. I merely wanted to express some irritation I had with some of your posts, indeed with a very tiny minority of your posts. I don&#039;t have any problem with you at all and don&#039;t want to fight with you (although I do love to debate things!), and I probably should have expressed myself in a less hostile way. So I apologize for any hostility perceived from me. <br /><br /><div class="quoteheader"><div class="topslice_quote">Quote</div></div><blockquote class="bbc_standard_quote">I did not intend to ever, at any time, state that Privnote is universally as secure as PGP encryption.&nbsp; If that is what you believe I meant, then you were absolutely correct in making sure to point out I was wrong.&nbsp; If what I said sounded like I really meant that, then some of the fault is indeed with me.&nbsp; That statement is a false one.<br /></blockquote><div class="quotefooter"><div class="botslice_quote"></div></div><br />Yes that is definitely how I took what you said. <br /><br /><div class="quoteheader"><div class="topslice_quote">Quote</div></div><blockquote class="bbc_standard_quote">Again, I didn&#039;t mean to say that.&nbsp; Now is there anything you would like to continue arguing about?&nbsp; Because I believe that is the root of this disagreement, and whether you like me or I like you aside, I believe that the discussion is done.&nbsp; I am, however, here and willing to participate in it further if you desire.&nbsp; So: are we done?<br /></blockquote><div class="quotefooter"><div class="botslice_quote"></div></div><br />I didn&#039;t mean to insult you personally, out of all of your 2,077 posts there have only been about 5 that bothered me. I just wanted to let you know how irritating I found you to be in those 5 posts, is all. If you want to continue arguing for or against javascript based cryptography, or related things, then I am game for that. However, otherwise I don&#039;t really care I think we both made all of our points related to Privnote and each other lol. 
			</dd>
		</dl>
		<div id="footer" class="smalltext">
			
			<span class="smalltext" style="display: inline; visibility: visible; font-family: Verdana, Arial, sans-serif;"><a href="http://dkn255hz262ypmii.onion/index.php?action=credits" title="Simple Machines Forum" target="_blank" class="new_win">SMF 2.0.5</a> |
 <a href="http://www.simplemachines.org/about/smf/license.php" title="License" target="_blank" class="new_win">SMF &copy; 2013</a>, <a href="http://www.simplemachines.org" title="Simple Machines" target="_blank" class="new_win">Simple Machines</a>
			</span>
		</div>
	</body>
</html>